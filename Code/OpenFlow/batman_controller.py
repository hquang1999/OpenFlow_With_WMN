"""
Handles routing configuration with the expectation that client nodes have the client app running to
report their local BATMAN config to this controller
"""


import json
import logging
import socket
from threading import Thread
from typing import Any

import simple_switch_13
from config import CONTROLLER_IP, PORT
from routing import Edge, FlowPath, Graph
from ryu.controller import ofp_event
from ryu.controller.controller import Datapath
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER, set_ev_cls
from ryu.controller.ofp_event import EventOFPMsgBase
from ryu.ofproto.ofproto_parser import MsgBase
from ryu.ofproto.ofproto_v1_3 import (
    OFP_DEFAULT_PRIORITY,
    OFP_VERSION,
    OFPCML_NO_BUFFER,
    OFPP_CONTROLLER,
)
from ryu.ofproto.ofproto_v1_3_parser import OFPActionOutput, OFPFlowMod, OFPMatch


class BatmanSwitch13(simple_switch_13.SimpleSwitch13):
    OFP_VERSIONS = [OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.graph = Graph()
        self.batman_msg_handler = Thread(target=batman_msg_handler(self), args=())
        self.batman_msg_handler.start()
        # datapaths of registered switches
        self.switches: set[Datapath] = set()
        # mesh network uuid to internal graph node id
        self.uuid_to_graph_id: dict[Any, int] = {}

    # uses event autogenerated by https://ryu.readthedocs.io/en/latest/ryu_app_api.html?highlight=event#openflow-event-classes
    # to register new switches so they can be sent new flows. Very similar to `SimpleSwitch13`'s handling with `self.mac_to_port`
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)  # type: ignore
    def active_switches_register(self, ev: EventOFPMsgBase):
        msg: MsgBase = ev.msg
        datapath: Datapath = msg.datapath
        self.switches.add(datapath)
        print(self.switches)


def batman_msg_handler(switch: BatmanSwitch13):
    def _batman_msg_handler():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(("", PORT))
        logging.info("Listening for BATMAN messages")
        while True:
            (msg, addr) = s.recvfrom(2**15)  # receive up to 2**15 bytes from any packet
            msg = json.loads(msg)
            print("\nreceived message", msg, addr)

            # Update info for the node.
            node_uuid = msg["self"]["id"]
            if (node_id := switch.uuid_to_graph_id.get(node_uuid)) is None or (
                node_weight := switch.graph.get_node(switch.uuid_to_graph_id[node_uuid])
            ) is None:
                # If not yet seen create it
                node_id = switch.graph.add_node({})
                switch.uuid_to_graph_id[node_uuid] = node_id
                node_weight = switch.graph.get_node(switch.uuid_to_graph_id[node_uuid])
                assert isinstance(node_weight, dict)
                node_weight["addresses"] = set()
            # batman address other nodes identify this as
            node_weight["addresses"].add(msg["self"]["batman_addr"])
            # switch address contained in the `datapath.address`
            node_weight["addresses"].add(msg["self"]["switch_addr"])
            # ip used to send the message
            node_weight["addresses"].add(addr[0])

            # debug info about the state of the graph
            print("graph nodes", switch.graph.node_weights())
            print("graph ids", switch.graph.node_indices())
            print(
                "graph edges",
                list(
                    map(
                        lambda x: switch.graph.edge_endpoints(x),
                        switch.graph.edge_indices(),
                    )
                ),
            )

            # Update node neighbors in graph by ...
            ## ... removing previous neighbors...
            for edge_id in switch.graph.edges_directed(node_id, True):
                switch.graph.remove_edge(edge_id)
            ## ... and adding new neighbors included in this message
            for neigh_msg in msg["neighbors"]:
                # Get graph id of first node with matching address to neighbor
                neigh_id = next(
                    filter(
                        lambda id: neigh_msg["neigh_address"]
                        in switch.graph.get_node(id)["addresses"],  # type: ignore
                        switch.graph.node_indices(),
                    ),
                    None,
                )

                if neigh_id is not None:
                    # Then add an edge with the given throughput
                    switch.graph.add_edge(
                        node_id,
                        neigh_id,
                        Edge(0, neigh_msg["throughput"]),
                    )

            # Add new flows to flowtables as needed
            ## Get controller graph id
            controller_id = next(
                filter(
                    lambda id: CONTROLLER_IP in switch.graph.get_node(id)["addresses"],  # type: ignore
                    switch.graph.node_indices(),
                ),
                None,
            )
            for datapath in switch.switches:
                print(f"Switch at datapath: {datapath.address}")
                # Get graph id of first node with matching address to datapath switch
                neigh_id = next(
                    filter(
                        lambda id: datapath.address[0]
                        in switch.graph.get_node(id)["addresses"],  # type: ignore
                        switch.graph.node_indices(),
                    ),
                    None,
                )
                if neigh_id is not None and controller_id is not None:
                    # Calculate paths back to controller
                    paths_back: list[FlowPath] = switch.graph.ranked_max_flow(
                        neigh_id, controller_id
                    )
                    print(f"Paths from node {neigh_id} to controller: {paths_back}")

                # TODO: Use computed flow from node to controller to determine what flows to add to what nodes
                #       Below is example of how to add/modify flows
                # ---------------------------------------------------------------------------------
                # TODO: Should use the below for dynamic negotiation, but lsp type inference works better by manual import.
                # ofproto = datapath.ofproto # module corresponding to negotiated openflow version ex. ryu.ofproto.ofproto_v1_3
                # parser = datapath.ofproto_parser # module corresponding to negotiated openflow version ex. ryu.ofproto.ofproto_v1_3_parser

                # look at `ryu.ofproto.ofproto_v1_3.oxm_types` for valid keys
                # TODO: this is a random key=value for testing
                # need to specify `eth_type = 2048` (ipv4) to use `ipv4_dst` match
                match = OFPMatch(in_port=4, eth_type=2048, ipv4_dst="50.50.50.5")
                # Specify NoBuffer to handle bug (see SimpleSwitch13 for reasoning)
                # TODO: Again testing with a simple output actions. one to controller port and one to port 1.
                actions = [
                    OFPActionOutput(OFPP_CONTROLLER, OFPCML_NO_BUFFER),
                    OFPActionOutput(1, OFPCML_NO_BUFFER),
                ]
                switch.add_flow(datapath, OFP_DEFAULT_PRIORITY, match, actions)
                # ---------------------------------------------------------------------------------

    return _batman_msg_handler
