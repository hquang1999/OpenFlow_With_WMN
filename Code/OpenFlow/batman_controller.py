"""
Handles routing configuration with the expectation that client nodes have the client app running to
report their local BATMAN config to this controller
"""


from routing import Edge, FlowPath, Graph
from ryu.controller import ofp_event
from ryu.controller.controller import Datapath
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER, set_ev_cls
from ryu.controller.ofp_event import EventOFPMsgBase
from ryu.ofproto.ofproto_parser import MsgBase
from ryu.ofproto.ofproto_v1_3 import (
    OFP_VERSION,
    OFPP_CONTROLLER,
    OFPCML_NO_BUFFER,
    OFP_DEFAULT_PRIORITY,
)
from ryu.ofproto.ofproto_v1_3_parser import OFPFlowMod, OFPMatch, OFPActionOutput
from threading import Thread
from typing import Set
import logging
import simple_switch_13
import socket
from batman_config import PORT


"""port for batman out of band messages"""


class TODO:
    """
    marker indicating unfinished
    """

    ...


class BatmanSwitch13(simple_switch_13.SimpleSwitch13):
    OFP_VERSIONS = [OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.graph = Graph()
        self.batman_msg_handler = Thread(target=batman_msg_handler(self), args=())
        self.batman_msg_handler.start()
        # datapaths of registered switches
        self.switches: Set[Datapath] = set()

    # uses event autogenerated by https://ryu.readthedocs.io/en/latest/ryu_app_api.html?highlight=event#openflow-event-classes
    # to register new switches so they can be sent new flows. Very similar to `SimpleSwitch13`'s handling with `self.mac_to_port`
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)  # type: ignore
    def active_switches_register(self, ev: EventOFPMsgBase):
        msg: MsgBase = ev.msg
        datapath: Datapath = msg.datapath
        self.switches.add(datapath)
        print(self.switches)


def batman_msg_handler(switch: BatmanSwitch13):
    def _batman_msg_handler():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(("", PORT))
        logging.info("Listening for BATMAN messages")
        while True:
            msg = s.recv(2**15)  # receive up to 2**15 bytes from any packet
            print(msg)  # TODO decode json with `json.loads`
            for datapath in switch.switches:
                # TODO: Should use the below for dynamic negotiation, but lsp type inference works better by manual import.
                # ofproto = datapath.ofproto # module corresponding to negotiated openflow version ex. ryu.ofproto.ofproto_v1_3
                # parser = datapath.ofproto_parser # module corresponding to negotiated openflow version ex. ryu.ofproto.ofproto_v1_3_parser

                # look at `ryu.ofproto.ofproto_v1_3.oxm_types` for valid keys
                # TODO: this is a random key=value for testing
                # need to specify `eth_type = 2048` (ipv4) to use `ipv4_dst` match
                match = OFPMatch(in_port=4, eth_type=2048, ipv4_dst="50.50.50.5")
                # Specify NoBuffer to handle bug (see SimpleSwitch13 for reasoning)
                # TODO: Again testing with a simple output actions. one to controller port and one to port 1.
                actions = [
                    OFPActionOutput(OFPP_CONTROLLER, OFPCML_NO_BUFFER),
                    OFPActionOutput(1, OFPCML_NO_BUFFER),
                ]
                switch.add_flow(datapath, OFP_DEFAULT_PRIORITY, match, actions)
                print(f"Added flow to {datapath.id}")

                # TODO: add handling here by updating graph edges, recomputing routes and resending flows based on routes
                # can use `add_flow` and `delete_flow` from base class such as:
                # switch.add_flow()

    return _batman_msg_handler
